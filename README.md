# Storm Manager for Minecraft Server
**StormWatch** is a plugin for Bukkit/Spigot Minecraft servers that hosts a dynamic, hot-pluggable API for
easily scheduling, managing, and manipulating custom weather events.

This plugin tentatively maintains regular updates to keep to-date with the _latest_ build of the Spigot API.

If you're interested in making your own plugin, documentation for the _StormWatch API_ can be found [on my personal site](https://xmit.xyz/spigot/StormWatch/manual.html),
though its availability may change every now and again as I work on my site.

If you don't care to read Javadoc, read on to the API section below.

# Default Storm Types
The plugin ships with three default Storm extensions prefabricated, which can be optionally tweaked or disabled in
the configuration file generated by the plugin.

All explosive properties of each default Storm type are configurable, including whether the explosions break blocks, do damage, etc.

- **Shower Storms** - Modeled after the classic Minecraft/Bukkit "MeteorShower" plugin, this Storm rains fireballs from the sky.
- **Streak Storms** - This Storm spawns harmless streaks of "shooting stars" above the head of the target player.
- **Impact Storms** - Something to be feared, this Storm casts a one-shot, gigantic ball of fury down onto (or near) the player. 
  This is by far the most customizable default Storm type.


# Using the API
As another reminder, more documentation about using the API _and_ the configuration can be found on my site.

See my [independent test plugin](https://github.com/NotsoanoNimus/Darude-Sandstorm-Test) for an example of how you can create your own managed Storm events!

Add StormWatch to your `plugin.yml` dependencies section:
```yml
depend: [StormWatch, (others)...]
```

Registering your Storm extension class:
```java
import xyz.xmit.StormWatch.StormWatch;
public class MyCustomStormPlugin extends JavaPlugin {
    @Override
    public void onEnable() {
        try {
            // Register your custom Storm type with the API/manager plugin.
            if(!StormWatch.getStormManager().registerNewStormType(MySuperStorm.class)) {
                throw new Exception("Failed to register the custom Storm type.");  
            } else { this.getLogger().log("Registered with StormWatch!"); }
        } catch (Exception ex) {
            this.getLogger().log(Level.ERROR,
                    "Failed to register plugin in StormWatch: " + ex.getMessage());
            // Disable the plugin automatically when a problem is detected.
            this.getPluginLoader().disablePlugin(this);
        }
    }
}
```

Creating a Storm extension class:
```java
import xyz.xmit.StormWatch.Storm;
import xyz.xmit.StormWatch.StormConfig;

public class MySuperStorm extends Storm {
    public static final String TYPE_NAME = "superstorm_by_me";   // <-- Must be GLOBALLY UNIQUE
    
    public enum SuperStormConfigKeyNames implements StormConfig.ConfigKeySet {
        // Registers config node "superstorm_by_me.subkeyName"
        //   You can add as many of these custom config nodes as you want.
        REQUIRED_CONF_KEY_1("subkeyName"),
    }
    public static final HashMap<String, Object> defaultConfig = new HashMap<>() {{
        // Gives a default configuration value to the REQUIRED_CONF_KEY_1 tag above.
        //   So this sets "superstorm_by_me.subkeyName" to ==> "I AM DEFAULT" in the StormWatch config.yml
        put(SuperStormConfigKeyNames.REQUIRED_CONF_KEY_1, "I AM DEFAULT");
    }};
    
    public MySuperStorm() {
        // Send the information to the base Storm class.
        super(MySuperStorm.TYPE_NAME, MySuperStorm.defaultConfig);
    }
    
    // [[[ ALL BASE CLASS ABSTRACT METHOD IMPLEMENTATIONS MUST FOLLOW ]]]
    // Don't fret about this, your IDE will help you out. :)
}
```

# TODO
Aside from completing all marked code TODOs, here are some future plans moving forward:
- [X] Add a string array to default Storm options, to exempt Storms from targeting worlds and/or players by name.
  - [X] Also add default options to the base Storm class for the same exemptions on a Storm-by-Storm level.
- [X] Chunk management and configuration on a per-storm basis.
- [ ] Command interface to enable/disable Storm types until the next reload: `/stormgr enable impact`
  - [ ] Commands for casting certain storms at target players. Thinking something like: `/stormgr cast impact SomePlayerName`
  - [ ] Should also add an option for any Storm types to have their own extra command parsing for `cast` calls; consider:
- [ ] Storm data collector/statistics class.
- [ ] Command to query information about StormWatch and Storm data.
```
/stormgr cast impact SomePlayerName [opt1 opt2 ... optN]
--- Create an Impact event, instantiated for SomePlayerName
----- The rest of the options are passed to the Impact event to handle:
opt1 = DIRECT ---> Meteor spawns right over the player and rushes downward. 
opt2 = HARMLESS -> The meteor doesn't do any damage or explode.

So the full command becomes...
/stormmgr cast impact SomePlayerName DIRECT HARMLESS

All Storm types can have this extensibility built in.
```
- [ ] Storm data collector/statistics class.
- [ ] (_PARTIALLY DONE_) Command to query information about StormWatch and Storm data.
- [ ] Create more custom Storm plugins, or built-in types.
- [ ] Consider deprecating the distinctions for _built-in types_ being completely immutable in the StormManager.