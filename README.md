# Storm Manager for Minecraft Server
**StormWatch** is a plugin for Bukkit/Spigot Minecraft servers that hosts a dynamic, hot-pluggable API for
easily scheduling, managing, and manipulating custom weather events.

This plugin tentatively maintains regular updates to keep to-date with the _latest_ build of the Spigot API.

If you're interested in making your own plugin, documentation for the _StormWatch API_ can be found [on my personal site](https://xmit.xyz/spigot/StormWatch/manual.html),
though its availability may change every now and again as I work on my site.

If you don't care to read Javadoc, read on to the API section below.

# Default Storm Types
The plugin ships with three default Storm extensions prefabricated, which can be optionally tweaked or disabled in
the configuration file generated by the plugin.

### Shower Storms

### Streak Storms

### Impact Storms


# Using the API
See my [independent test plugin](https://github.com/NotsoanoNimus/Darude-Sandstorm-Test) for an example of how you can create your own managed Storm events!

Registering your Storm extension class:
```java
public class MyCustomStormPlugin extends JavaPlugin {
    @Override
    public void onEnable() {
        if(this.getServer().getPluginManager().getPlugin("StormWatch") != null) {
            StormWatch.getStormManager().registerNewStormType(MySuperStorm.class);
        } else {
            this.getLogger().log(Level.WARNING, "Could not register the MySuperStorm class for StormWatch!");
        }
    }
}
```

Creating a Storm extension class:
```java
import xyz.xmit.StormWatch.Storm;
public class MySuperStorm extends Storm {
    public static final String TYPE_NAME = "superstorm_by_me";   // <-- Must be GLOBALLY UNIQUE
    public enum SuperStormConfigKeyNames implements StormConfig.ConfigKeySet {
        REQUIRED_CONF_KEY_1("subkeyName"),   // Registers config node "superstorm_by_me.subkeyName"
    }
    public static final HashMap<String, Object> defaultConfig = new HashMap<>() {{
        // Gives a default configuration value to the REQUIRED_CONF_KEY_1 tag above.
        //   So this sets "superstorm_by_me.subkeyName" to ==> "I AM DEFAULT" in the StormWatch config.yml
        put(SuperStormConfigKeyNames.REQUIRED_CONF_KEY_1, "I AM DEFAULT");
    }};
    public MySuperStorm() {
        super(MySuperStorm.TYPE_NAME, MySuperStorm.defaultConfig);
    }
    // [[[ ALL METHOD IMPLEMENTATIONS OF THE BASE CLASS MUST FOLLOW ]]]
}
```

# TODO
- [ ] Add a string array to default Storm options, to exempt Storms from targeting worlds and/or players by name.
- [X] Chunk management and configuration on a per-storm basis.
- [ ] Command interface to enable/disable Storm types until the next reload: `/stormgr enable impact`
  - [ ] Commands for casting certain storms at target players. Thinking something like: `/stormgr cast impact SomePlayerName`
  - [ ] Should also add an option for any Storm types to have their own extra command parsing for `cast` calls; consider:
```
/stormgr cast impact SomePlayerName [opt1 opt2 ... optN]
--- Create an Impact event, instantiated for SomePlayerName
----- The rest of the options are passed to the Impact event to handle:
opt1 = DIRECT ---> Meteor spawns right over the player and rushes downward. 
opt2 = HARMLESS -> The meteor doesn't do any damage or explode.

So the full command becomes...
/stormmgr cast impact SomePlayerName DIRECT HARMLESS

All Storm types can have this extensibility built in.
```